# Near Real-Time Peer-to-Peer Shared Editing on Extensible Data Types

## Abstract

实时协作通常使用`OT`(Operational Transformation), 现在又流行起来 `CRDT`(Commutative Replicated Data Types)。但是大多数已有的实现方法都不是通用的，需要在可读性、基础设施、性能和复杂度之间进行权衡。同时随着`WebRTC`这种多路客户端通讯技术的广泛使用，创造了对性能良好的支持P2P的算法的需求。

本文出了算法`YATA`, 为P2P实时协作设计，能保证结果收敛，保护用户的操作意图，支持离线编辑，并可用于 Web 浏览器中的任意数据类型。


## 介绍

`NRT 协作技术`(近实时协作技术), 常规使用`OT`。优点是不需要任何锁定机制来确保数据一致性。在一个`NRT`场景中，用户修改的内容会立刻写入本地的`Copy`，同时利用通讯协议，将这些修改的内容通知给其他客户端。所有数据的`Copy` 最终都应该数据一致，无论收到的操作的次序是否相同，或遇到信息传递的错误，比如临时断线等等。

Web 技术的进步带来了一些高速可靠的通讯协议，比如`WebRTC`,`WebSockets`, `XMPP over Websockets`, `Server-Sent Events`。这些技术推动了`P2P`协同编辑算法，并为算法提供了快速可靠的基础设施。`P2P`实现成为了一个传统`client-server`实现的一个可行的替代。每一个协作者在 `多路通讯`(N-way communication)中获取更新信息并且应用给本地，无需来自中心服务器的确认数据、指令或者转换操作。因此现有的NRT协作算法需要适应新的性能要求。这不是一项简单的任务，特别是在大规模协作的情况下，随着用户数量的增加和变化(`client-server`模式下连接数量是固定的)。

绝大部分`OT`算法是为`client-server`模式设计。其中支持`P2P`多路通讯的算法依旧需要在每一个消息中附带一个`state vector`(状态向量)。此外。需要在服务器端进行预处理的算法不能用于`P2P`环境。`CRDT`算法些具有较小的文件更新规模，并且不依赖`vector clocks`(矢量时钟)。因此可以适应新的通信协议和网络上的做法。

`YATA`(Yet Another Transformation Approach)设计目标就是为了克服这些现有算法的缺陷。这个算法确保了数据一致性、协作编辑时的编辑意图保留。 `YATA`从设计上会引发更少的数据冲突，更好的时间复杂度，支持离线编辑（比如支持客户端加入一个存在未同步修改的协作会话），支持多种数据类型。算法内部使用了`链表`的数据结构。此外`YATA`引入了一个垃圾回收器来避免急剧增加的无用的操作，以解决常见的`CRDT`算法中保留被删除操作导致的性能损失。

`Yjs` 是这个算法的一个开源实现，已经证明了这个算法性能优异，对于小型程序而言，协作机制很容易编写。

## 相关工作

过往的研究提出了多种技术来解决协同编辑环境下的冲突。20世纪80年代末提出了并发控制(包括悲观锁、互斥锁)，事务机制，single active participation (token-based participation)，依赖检测（冲突检测时间戳)，差异同步机制（client-server异步实现)和三路合并（经典版本管理系统）。

最优秀的乐观并发控制实现机制是`OT`和`CRDT`。`OT`算法需要指明一个`控制算法`和`转换函数`。`控制算法`决定了并发操作需要根据并法/上下文关系，针对其他操作进行转换。`转换函数`决定了如何根据操作的类型、位置和其他参数进行一次转换操作。这两个组件的由一组转换属性和条件定义的。于此相反，CRDT算法通过定义互补冲突的元操作的方法来提供乐观的并发控制。

Google Wave/Google docs 采用的是`OT`实现，基于`Jupiter`(High-latency, Low-bandwidth Windowing in the Jupiter Collaboration System)算法。无论服务器和客户端都必须预处理`Operation`后再执行它，此外服务器还需要传播转换后的`Operation`。客户端之间并不直接互访。（介绍一系列改良算法）

总而言之，`OT`方法仍然有几个缺点，比如在P2P环境、动态（加入/离开）用户的云网络环境中的伸缩性问题，以及解决收敛问题的高度复杂性。这就是为什么大多数`OT`实现被限制在线性数据结构或特定的数据结构，如`树形`的原因。此外，复杂性也是在随着谷歌和基于云的系统的兴起，协作应用也在蓬勃发展的大环境下，拖慢协作应用大规模铺开的一个原因。