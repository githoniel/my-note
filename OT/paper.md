# Operational Transformation in Real-time Group Editors: Issues, Algorithms, and Achievements（1998 ACM Reference）

## Abstract

保持一致性是实时协作系统设计中最重要的挑战。综合性的回顾一下`OT`算法，提出其中的主要问题、算法、成就以及遗留的挑战，同时提供了一个优化算法。

## Keyword

Consistency maintenance: 保持一致性
Operational transformation: 转换操作化
Convergence: 收敛
Causality preservation: 保持因果关系
Intention preservation: 保持意图

## Intro

实时协作的问题是在短响应时间限制下的文档的一致性保持，在分布式环境下支持并发编辑。

`OT` 算法在1989年的 `GROVE` 系统中首创。

本论文会重点关注`OT`算法的一致性保持。还有其他的一致性保持技术，比如轮流编辑、锁、序列化和事务化等等。

论文内容顺序

1. 介绍基础概念和术语
2. GROVE系统的算法介绍
3. GROVE算法中的问题，以及三种解决办法，包括`REDUCE`、`Jupiter`和`adOPTed`
4. 提出一个新的优化算法`GOT`(Generic Operational Transformation)
5. 总结下取得成果以及遗留问题

## Preliminaries

### 定义1: 执行顺序关系 “->”

对于2个操作`Oa`和`Ob`，分别产生于站点`i`和`j`,则 `Oa -> Ob`当且仅当

1. `i =j`时，`Oa`先于`Ob`产生。
2. `i != j`时，`Oa`在`j`站点的执行先于`Ob`操作的产生。(注意是传播后的执行先于本地的操作产生)
3. 存在其他的操作`Ox`，满足`Oa -> Ox`, `Ox -> Ob`

### 定义2: 独立和非独立操作

对于2个操作`Oa`和`Ob`

1. `Ob`依赖`Oa`当切仅当`Oa -> Ob`
2. `Oa`和`Ob`是独立的，表示为`Oa || Ob`，当切仅当`Oa -> Ob`和`Ob -> Oa`均不成立

### Demo

![fig-1](img/fig-1.png)

`O1 -> O3`
`O2 -> O3`
`O2 -> O4`

`O1 || O2`
`O1 || O4`
`O3 || O4`
## GROVE实现

为了体验良好的响应速度，避免系统单点故障，`GROVE`实现采用了一个可复制的结构：每一个参与的站点都在本地保存了一份共享文档的复制品。本地操作在产生后会立刻在本地的复制品上执行并且传播给远端站点（在一些延迟和转换后）。

### 发散和因果关系违反的问题

假设远端操作在他们到达站点后立刻以原始内容执行，将会导致2个不一致问题。

各个端的执行`OT`的次序不同，会导致最终结果不同，这就叫`发散(divergence)`。显然发散应该被禁止，最终结果应该是一致的。

由于每个端执行`OT`的次序不同，操作次序可能颠倒因果关系。比如`site0`传播`Oa`给`site1`后，`site1`执行`Oa`后用户基于`Oa`的内容，生成并且执行`Ob`，此时`Oa -> Ob`。对于`site2`，可能会先收到`Ob`，再收到`Oa`，如果`Ob`操作的内容是基于`Oa`的内容，则会导致`site2`中`Ob`内容无法定义。对于`site2`的用户而言，先观察到后发的`Ob`的结果之后，才观察到原因`Oa`。这个问题叫`因果关系违反(causality-violation)`。显然这也应该被禁止。

### 一致性的正确性的规则

基于这两个问题的识别，`GROVE`定义了下面2个原则:

1. 收敛原则：所有文档的复制品在静止状态（所有`OT`在所有站点都执行完毕）下应当一致
2. 优先原则：如果一个操作`Oa`在因果关系上先于`Ob`，则在任何站点上，`Oa`应当早于`Ob`执行。

`GROVA`在寻找要求`执行顺序=因果顺序`的解决方法的研究中，发明了后来著名的`distributed OPerational Transformation(dOPT)`算法。`GROVE`的解决方案由2个组件组成：

1. 时间戳状态向量, 用于执行的优先级顺序
2. `dOPT`算法用于确保一致性

`dOPT`算法的基本思路是，如果一个操作满足执行的优先级条件时，首先会根据`Log(所有已执行的操作都会被按次序记录下来)`中的独立操作，被转换为执行独立操作的次序不会生成相同结果的操作，来确保一致性。

### 转换函数

为了确保一致性，`dOPT`算法要求转换函数`T`满足：

对于任意2个独立的操作`Oa`和`Ob`，假设`Oa' = T(Oa, Ob)`，`Ob' = T(Ob, Oa)`，则有

`Oa * Ob'` === `Ob * Oa'`

PS: `T(Oa,Ob)`表示在`Ob`执行的基础上转换`Oa'`，类似于`slatejs`中的`ref`操作

除了上述条件外，GROVE同时识别出转换函数`T`应当实现一些`不可序列化`的效果(意思是有一些边界情况)。比如`Oa`，`Ob`同时删除同一个字符，则转换函数`T`应当确保只有一个字符被删除，无论两个操作的执行次序先后。

### `dOPT`算法简叙

转换函数`T`和具体的操作语义相关，所以是随应用而不同的。但是`dOPT`算法是通用的，而且负责了选区操作(Selecting Operation)并决定了转换次序。基础控制流程比较简单: 对于一个已经处理好因果关系的操作`O`

1. 扫描`LOG`, 找出所有和`O`独立的所有`OP`: `OPS`
2. `EO = OPS.reduce(T(O, OP))`
3. 执行`EO`，并且保存到`LOG`中

### 一个`dOPT`未解决的问题

![Fig.2](img/fig-2.png)

`GROVE`存在站点优先级，按数字递增，则上图获得结果

site2: z -> xz -> (site3优先，O3优先, O3的因果01被传递优先) ->xzy
site1: x -> xz -> (site3优先，O3优先, O3的因果01被传递优先) -> zxy
site3: y -> (site3优先) -> zy -> (O2优先于O1) -> zxy

这个问题的根源被认为在于简单直白的站点优先级。有论文提出一个复杂的优先级结构来尝试解决这个问题，但是无法自证。

用`OP`保持一致性的创新方法以及这个未解决的问题，很大程度上启发和刺激了大把的研究人员。诸多研究团队，都独立的发现了，


**当一个`OP`和2个或者更多独立的`OP`并发时候，`dOPT`算法无法保证一致性。**

各种实现都提出了一些修正方法，接下来介绍其中三种: `REDUCE`(使用一个一维数据结构来追踪已执行的操作)、`Jupiter`(使用一个二维数据结构来追踪已执行的操作)和`adOPTed`(使用一个N维数据结构来追踪已执行的操作, N为终端数)

## `REDUCE`实现

`REDUCE`跟随`GROVE`采用了一个完全分布式和复制品的系统架构。一个线性的`HistoryBuffer`用于保存所有的已执行的操作(相当于`GROVE`中的`LOG`)。此外还设计了一个垃圾回收机制来移除无用的操作记录。

### 违反编辑意图(intention-violation)问题

除了发散和因果关系违反的问题, `REDUCE`算法还识别到了一类特殊的不一致问题: `违反编辑意图`。

回顾下前面的例子：![fig-1](img/fig-1.png)

考虑两个独立操作`O1 || O2`，用户产生`O2`的时候，本地并没有`O1`，但是在站点0上，`O2`执行于`O1`之后，这可能会导致错误的文档位置，导致最终的编辑结果和`O2`的意图不同。

比如文档的初始内容为`ABCDE`

- `O1 = Insert("12", 2)`，`site0`得到`ABCDE -> A12BCDE -> A1CDE`
- `O2 = Delete(3, 2)`, `site1`得到`ABCDE -> ABE -> A12BE`

PS: 注意这里是为了演示问题所在，没有做`转换函数T`

正确的`保留编辑意图`的结果应该为`A12BE`

这里的区别在于，`发散`是各个端数据不一致，可以通过强制各个端按序执行来解决，但是`违反编辑意图`不可以。

### 一致性模型

`REDUCE`在识别到上述不一致问题智商，提出了实现`保留意图(intention-preservation)`这一额外的一致性的正确性的规则。

定义3: 一种一致性模型

如果一个协同编辑系统总是遵循下面原则，则它会实现一致性：

1. 收敛原则：所有文档的复制品在静止状态（所有`OT`在所有站点都执行完毕）下应当一致
2. 优先原则：如果一个操作`Oa`在因果关系上先于`Ob`，则在任何站点上，`Oa`应当早于`Ob`执行。
3. 保留意图原则：对任何操作`O`, 在所有站点上执行`O`的效果都应当与`O`的意图相同。而且执行`O`的效果不改变其他独立操作的效果。

为了支持这三个原则下的一致性模型，`REDUCE`和`GROVE`同样采用了基于时间戳的状态向量结构来实现保留因果关系。此外还引入了2个额外的结构来支持2个原则：一个`undo`/`do`/`redo`结构来保证`收敛原则`，一个`OP`转换算法来实现`保留意图原则。


引入符号`=>`代表`OP`之间的总的排序关系。虽然`OP`在满足因果关系的前提下可以在任意顺序下执行。

当一个新`OP`已经满足因果关系准备执行的时候
1. `undo`: 生成一个`O`的逆操作`O1`用于恢复文档到`O`执行之前
2. `do`: 执行`O`
3. `redo`: 回滚被撤销的操作

### 转换的前置后置条件

既然`REDUCE`中的转换函数并不负责确保一致性，所以并不要求满足`GROVE`中相同的条件。

在`REDUCE`中, 假设操作`Oa`针对`Ob`转换为`Oa'`(`Oa' = T(Oa, Ob)`), 则要求`Oa'`在文档(已经执行过`Ob`)上的执行效果，应当和`Oa`在文档上的执行效果相同(没有执行过`Ob`)。这种转换为称为`包容性转换(Inclusion Transformation)`，因为操作`Oa`针对`Ob`的转换结果，包含了`Ob`对文档的影响。`GRAVE`中的转换函数也可以视为一种包容性转换。最重要的是，包容型转换依赖于`Oa`和`Ob`是基于**同一个文档状态**定义的，只有这样子两者才是可转换的。`dOPT`未解决的问题的根源就是没有识别到并确保这个条件。

为了实现`意图保留`，`REDUCE`还引入了另外一种新的转换: `排除性转换(Exclusion Transformation)`。在这种转换中，假设操作`Oa`针对`Ob`转换为`Oa'`(`Oa' = T(Oa, Ob)`)，则要求`Oa'`完全排除`Ob`的影响。比如`fig-1`中，`O4 || O1`，而且两个操作是在不同的站点中生成。当站点0收到`O4`的时候，直接针对`O1`转换`O4`是错误的。应先针对`O4`的先序操作`O2`做排除性转换获得`O4'`，来排除`O2`的影响。这种情况下，`O4'`和`O1`共享相同的文档状态，可以针对`O1`做包容性转换。

为了捕捉`OP`之间的正确转换关系，需要引入操作的`context`。文档状态的`context`在初始文档状态基础上，已执行的使文档状态到达当前值的**已执行操作的序列**。对于给定的一个操作`O`, 

- 操作`O`的`定义context(definition context)`，记做`DC(O)`, 是定义操作`O`的文档状态。
- 操作`O`的`执行context(execution context)`, 记错`EC(O)`，是执行`O`的文档状态。

如果`DC(O) === EC(O)`，则操作的执行意图得到了保留。

`REDUCE`采用了两种转换方法`IT(Oa, Ob)`和`ET(Oa, Ob)`来实现`DC(O) === EC(O)`。为了说明转换函数的前置和后置条件，定义了2个`context`相关的关系(`context`表达为一个操作数组)

- `context`关系`⊔`: 对于操作`Oa`和操作`Ob`, `Oa ⊔ Ob iff DC(Oa) === DC(Ob)`
- `context`前序关系`↦`: 对于操作`Oa`和操作`Ob`, `Oa ↦ Ob iff DC(Ob) = DC(Oa) + [Oa]`(加法为数组合并)

基于上述定义，两种操作的前置和后置条件如下:

- **规范1**: `IT(Oa, Ob): Oa'`
1. 前置条件: `Oa ⊔ Ob`
2. 后置条件: `Ob ↦ Oa'`, 并且`Oa'`在`DC(Oa')`的效果和`Oa`在`DC(Oa)`的效果一致。

- **规范2**: `ET(Oa, Ob): Oa'`
1. 前置条件: `Ob ↦ Oa`
2. 后置条件: `Ob ⊔ Oa'`, 并且`Oa'`在`DC(Oa')`的效果和`Oa`在`DC(Oa)`的效果一致。

## `GOT`控制算法

`GOT`控制算法的设计目的是为了确保转换的前置条件。对于一个已满足因果关系的操作`O`，其`执行context`为`EC(O)`。`GOT`控制算法使用`IT/ET`函数，转换操作`O`为操作`EO(操作的执行形态)`，使得`DC(EO) === EC(O)`。

`GOT`控制算法分为三种情况，假设`EC(O)= HB = [EO1, EO2, EO3]`，如图

![fig-3](img/fig-3.png)

- case 1: `EC(O)`中的所有操作都前序于`O`，则`DC(O) === EC(O)`并且`EO === O`
- case 2: 操作`O`的因果前序操作都在`O`的独立操作之前，比如`E1 -> O`, `E02 || O`, `E03 || O`，则按照顺序针对`E02`, `E03`包容性转换`O`得到`EO`，`DC(O) === EC(O)`
- case 3: 至少有一个因果前序关系在独立操作之后，这就是`dOPT`算法无法正确处理的情况， 比如`E1 -> O`, `E02 || O`, `E03 -> O`, 则`DC(O) = [EO1, EO3']`, `EO3'`为`EO3`在操作`O`生成时候的初始状态。此时应当`E03' = ET(EO3, EO2)`, `O' = ET(O, O3')`, 然后按照顺序针对`E02`, `E03`转换`O'`得到`EO`，`DC(O) === EC(O)`

为了描述算法还需要引入一些概念, 对于给定的一个操作数组`L`

- `L[i, j]`: L.sub(i, j)
- `L-1`: L倒序
- `LIT(O, L)/LET(O, L)`: L.forEach((l) => IT/ET(O, l))

### 算法描述

GOT(O, L): EO
O: 一个满足因果关系的操作
L: EC(O): [EO1, EO2,...,EOm]
EO: O的执行态

1. 从左到右扫描L[1, m]，寻找第一个`EOk || O`，如果没有，则返回EO = O
2. 否则，寻找L[k+1, m]，寻找所有因果前序`O`的操作，如果没有，则返回EO = LIT(O, K[k, m])
3. ![fig-4](img/fig-4.png)

这里充分利用了前置和后置条件，转换满足了一致性和意图保留，还可以支持撤销和重做。

### 解决`dOPT`问题